package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/smart-contract-event-indexer/api-gateway/graph/generated"
	"github.com/smart-contract-event-indexer/api-gateway/graph/model"
	"github.com/smart-contract-event-indexer/shared/models"
	protoapi "github.com/smart-contract-event-indexer/shared/proto"
)

// ID is the resolver for the id field.
func (r *contractResolver) ID(ctx context.Context, obj *models.Contract) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Address is the resolver for the address field.
func (r *contractResolver) Address(ctx context.Context, obj *models.Contract) (string, error) {
	return string(obj.Address), nil
}

// StartBlock is the resolver for the startBlock field.
func (r *contractResolver) StartBlock(ctx context.Context, obj *models.Contract) (string, error) {
	return fmt.Sprintf("%d", obj.StartBlock), nil
}

// CurrentBlock is the resolver for the currentBlock field.
func (r *contractResolver) CurrentBlock(ctx context.Context, obj *models.Contract) (string, error) {
	return fmt.Sprintf("%d", obj.CurrentBlock), nil
}

// IsActive is the resolver for the isActive field.
func (r *contractResolver) IsActive(ctx context.Context, obj *models.Contract) (bool, error) {
	// All registered contracts are considered active until paused (feature TBD).
	return true, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *contractResolver) CreatedAt(ctx context.Context, obj *models.Contract) (string, error) {
	return obj.CreatedAt.UTC().Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *contractResolver) UpdatedAt(ctx context.Context, obj *models.Contract) (string, error) {
	return obj.UpdatedAt.UTC().Format(time.RFC3339), nil
}

// LatestBlock is the resolver for the latestBlock field.
func (r *contractStatsResolver) LatestBlock(ctx context.Context, obj *models.ContractStats) (string, error) {
	return fmt.Sprintf("%d", obj.LatestBlock), nil
}

// LastIndexedAt is the resolver for the lastIndexedAt field.
func (r *contractStatsResolver) LastIndexedAt(ctx context.Context, obj *models.ContractStats) (*string, error) {
	if obj.LastUpdated.IsZero() {
		return nil, nil
	}
	val := obj.LastUpdated.UTC().Format(time.RFC3339)
	return &val, nil
}

// ID is the resolver for the id field.
func (r *eventResolver) ID(ctx context.Context, obj *models.Event) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ContractAddress is the resolver for the contractAddress field.
func (r *eventResolver) ContractAddress(ctx context.Context, obj *models.Event) (string, error) {
	return string(obj.ContractAddress), nil
}

// BlockNumber is the resolver for the blockNumber field.
func (r *eventResolver) BlockNumber(ctx context.Context, obj *models.Event) (string, error) {
	return fmt.Sprintf("%d", obj.BlockNumber), nil
}

// BlockTimestamp is the resolver for the blockTimestamp field.
func (r *eventResolver) BlockTimestamp(ctx context.Context, obj *models.Event) (string, error) {
	return obj.Timestamp.UTC().Format(time.RFC3339), nil
}

// TransactionHash is the resolver for the transactionHash field.
func (r *eventResolver) TransactionHash(ctx context.Context, obj *models.Event) (string, error) {
	return string(obj.TransactionHash), nil
}

// Args is the resolver for the args field.
func (r *eventResolver) Args(ctx context.Context, obj *models.Event) ([]*models.EventArg, error) {
	if len(obj.Args) == 0 {
		return nil, nil
	}

	args := make([]*models.EventArg, 0, len(obj.Args))
	for key, value := range obj.Args {
		args = append(args, &models.EventArg{
			Name:  key,
			Type:  fmt.Sprintf("%T", value),
			Value: fmt.Sprintf("%v", value),
		})
	}
	return args, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *eventResolver) CreatedAt(ctx context.Context, obj *models.Event) (string, error) {
	return obj.CreatedAt.UTC().Format(time.RFC3339), nil
}

// Key is the resolver for the key field.
func (r *eventArgResolver) Key(ctx context.Context, obj *models.EventArg) (string, error) {
	return obj.Name, nil
}

// Value is the resolver for the value field.
func (r *eventArgResolver) Value(ctx context.Context, obj *models.EventArg) (string, error) {
	return fmt.Sprintf("%v", obj.Value), nil
}

// AddContract is the resolver for the addContract field.
func (r *mutationResolver) AddContract(ctx context.Context, input models.AddContractInput) (*model.AddContractPayload, error) {
	req := &protoapi.AddContractRequest{
		Address:       string(input.Address),
		Abi:           input.ABI,
		Name:          input.Name,
		StartBlock:    input.StartBlock,
		ConfirmBlocks: int32(input.GetConfirmBlocks()),
	}

	resp, err := r.AdminClient.AddContract(ctx, req)
	if err != nil {
		return nil, err
	}

	payload := &model.AddContractPayload{
		Success: resp.Success,
		IsNew:   resp.IsNew,
		Message: resp.Message,
	}

	if resp.Contract != nil {
		id := fmt.Sprintf("%d", resp.Contract.Id)
		payload.ContractID = &id
	}

	return payload, nil
}

// RemoveContract is the resolver for the removeContract field.
func (r *mutationResolver) RemoveContract(ctx context.Context, address string) (*model.RemoveContractPayload, error) {
	resp, err := r.AdminClient.RemoveContract(ctx, &protoapi.RemoveContractRequest{
		Address: string(address),
	})
	if err != nil {
		return nil, err
	}
	return &model.RemoveContractPayload{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// TriggerBackfill is the resolver for the triggerBackfill field.
func (r *mutationResolver) TriggerBackfill(ctx context.Context, input model.BackfillInput) (*model.BackfillPayload, error) {
	from, err := strconv.ParseInt(input.FromBlock, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid fromBlock: %w", err)
	}
	to, err := strconv.ParseInt(input.ToBlock, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid toBlock: %w", err)
	}

	resp, err := r.AdminClient.TriggerBackfill(ctx, &protoapi.BackfillRequest{
		ContractAddress: input.ContractAddress,
		FromBlock:       from,
		ToBlock:         to,
	})
	if err != nil {
		return nil, err
	}

	return backfillPayloadFromProto(resp), nil
}

// UpdateContract is the resolver for the updateContract field.
func (r *mutationResolver) UpdateContract(ctx context.Context, address string, confirmBlocks *int, isActive *bool) (*model.AddContractPayload, error) {
	if confirmBlocks == nil && isActive == nil {
		return nil, errors.New("no update fields provided")
	}

	addr := strings.ToLower(string(address))
	contract, err := getContractByAddress(ctx, r.DB, addr)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("contract %s not found", address)
		}
		return nil, err
	}

	var messages []string
	success := false

	if confirmBlocks != nil {
		if *confirmBlocks < 1 || *confirmBlocks > 100 {
			return nil, fmt.Errorf("confirmBlocks must be between 1 and 100")
		}
		query := `UPDATE contracts SET confirm_blocks = $1, updated_at = NOW() WHERE LOWER(address) = $2`
		if _, err := r.DB.ExecContext(ctx, query, *confirmBlocks, addr); err != nil {
			return nil, err
		}
		messages = append(messages, fmt.Sprintf("Confirmation blocks updated to %d", *confirmBlocks))
		success = true
	}

	if isActive != nil {
		if !*isActive {
			_, err := r.AdminClient.RemoveContract(ctx, &protoapi.RemoveContractRequest{Address: string(address)})
			if err != nil {
				return nil, err
			}
			messages = append(messages, "Contract deactivated")
			success = true
		} else {
			messages = append(messages, "Contract already active")
		}
	}

	if len(messages) == 0 {
		messages = append(messages, "No changes applied")
	}

	payload := &model.AddContractPayload{
		Success: success,
		IsNew:   false,
		Message: strings.Join(messages, "; "),
	}

	if contract != nil {
		id := fmt.Sprintf("%d", contract.ID)
		payload.ContractID = &id
	}
	return payload, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, filter *models.EventFilter, pagination *model.PaginationInput) (*models.EventConnection, error) {
	req := &protoapi.EventQuery{}
	applyEventFilter(req, filter)
	applyPagination(req, pagination)

	resp, err := r.QueryClient.GetEvents(ctx, req)
	if err != nil {
		return nil, err
	}

	return eventConnectionFromProto(resp), nil
}

// EventsByTransaction is the resolver for the eventsByTransaction field.
func (r *queryResolver) EventsByTransaction(ctx context.Context, txHash string) ([]*models.Event, error) {
	resp, err := r.QueryClient.GetEventsByTransaction(ctx, &protoapi.TransactionQuery{
		TransactionHash: txHash,
	})
	if err != nil {
		return nil, err
	}
	return eventsFromProto(resp.Events), nil
}

// EventsByAddress is the resolver for the eventsByAddress field.
func (r *queryResolver) EventsByAddress(ctx context.Context, address string, pagination *model.PaginationInput) (*models.EventConnection, error) {
	req := &protoapi.AddressQuery{
		Address: string(address),
	}
	if pagination != nil {
		if pagination.First != nil {
			req.First = int32(*pagination.First)
		}
		if pagination.After != nil {
			req.After = *pagination.After
		}
		if pagination.Before != nil {
			req.Before = *pagination.Before
		}
		if pagination.Last != nil {
			req.Last = int32(*pagination.Last)
		}
	}

	resp, err := r.QueryClient.GetEventsByAddress(ctx, req)
	if err != nil {
		return nil, err
	}
	return eventConnectionFromProto(resp), nil
}

// Contract is the resolver for the contract field.
func (r *queryResolver) Contract(ctx context.Context, address string) (*models.Contract, error) {
	contract, err := loadContract(ctx, r.DB, address)
	if err != nil {
		return nil, err
	}
	return contract, nil
}

// Contracts is the resolver for the contracts field.
func (r *queryResolver) Contracts(ctx context.Context, isActive *bool) ([]*models.Contract, error) {
	resp, err := r.AdminClient.ListContracts(ctx, &protoapi.ListContractsRequest{
		Limit:  50,
		Offset: 0,
	})
	if err != nil {
		return nil, err
	}
	contracts := contractsFromProto(resp.Contracts)
	if isActive != nil && !*isActive {
		return []*models.Contract{}, nil
	}
	return contracts, nil
}

// ContractStats is the resolver for the contractStats field.
func (r *queryResolver) ContractStats(ctx context.Context, address string) (*models.ContractStats, error) {
	stats, err := loadContractStats(ctx, r.DB, address)
	if err != nil {
		return nil, err
	}
	return stats, nil
}

// SystemStatus is the resolver for the systemStatus field.
func (r *queryResolver) SystemStatus(ctx context.Context) (*model.SystemStatus, error) {
	statusResp, err := r.AdminClient.GetSystemStatus(ctx, &protoapi.Empty{})
	if err != nil {
		return nil, err
	}

	var lastIndexed *string
	if statusResp.LastIndexedBlock != 0 {
		val := fmt.Sprintf("%d", statusResp.LastIndexedBlock)
		lastIndexed = &val
	}

	return &model.SystemStatus{
		IndexerLag:       int(statusResp.IndexerLag),
		TotalContracts:   int(statusResp.TotalContracts),
		TotalEvents:      int(statusResp.TotalEvents),
		CacheHitRate:     statusResp.CacheHitRate,
		LastIndexedBlock: lastIndexed,
		IsHealthy:        statusResp.IsHealthy,
		Uptime:           int(statusResp.Uptime),
	}, nil
}

// Address is the resolver for the address field.
func (r *addContractInputResolver) Address(ctx context.Context, obj *models.AddContractInput, data string) error {
	obj.Address = models.Address(data)
	return nil
}

// StartBlock is the resolver for the startBlock field.
func (r *addContractInputResolver) StartBlock(ctx context.Context, obj *models.AddContractInput, data string) error {
	value, err := strconv.ParseInt(string(data), 10, 64)
	if err != nil {
		return err
	}
	obj.StartBlock = value
	return nil
}

// ContractAddress is the resolver for the contractAddress field.
func (r *eventFilterResolver) ContractAddress(ctx context.Context, obj *models.EventFilter, data *string) error {
	if data == nil {
		obj.ContractAddress = nil
		return nil
	}
	addr := models.Address(*data)
	obj.ContractAddress = &addr
	return nil
}

// FromBlock is the resolver for the fromBlock field.
func (r *eventFilterResolver) FromBlock(ctx context.Context, obj *models.EventFilter, data *string) error {
	if data == nil {
		obj.FromBlock = nil
		return nil
	}
	value, err := strconv.ParseInt(string(*data), 10, 64)
	if err != nil {
		return err
	}
	obj.FromBlock = &value
	return nil
}

// ToBlock is the resolver for the toBlock field.
func (r *eventFilterResolver) ToBlock(ctx context.Context, obj *models.EventFilter, data *string) error {
	if data == nil {
		obj.ToBlock = nil
		return nil
	}
	value, err := strconv.ParseInt(string(*data), 10, 64)
	if err != nil {
		return err
	}
	obj.ToBlock = &value
	return nil
}

// Addresses is the resolver for the addresses field.
func (r *eventFilterResolver) Addresses(ctx context.Context, obj *models.EventFilter, data []string) error {
	if len(data) == 0 {
		obj.Addresses = nil
		return nil
	}
	addresses := make([]models.Address, len(data))
	for i, value := range data {
		addresses[i] = models.Address(value)
	}
	obj.Addresses = addresses
	return nil
}

// TransactionHash is the resolver for the transactionHash field.
func (r *eventFilterResolver) TransactionHash(ctx context.Context, obj *models.EventFilter, data *string) error {
	if data == nil {
		obj.TransactionHash = nil
		return nil
	}
	hash := models.Hash(*data)
	obj.TransactionHash = &hash
	return nil
}

// Contract returns generated.ContractResolver implementation.
func (r *Resolver) Contract() generated.ContractResolver { return &contractResolver{r} }

// ContractStats returns generated.ContractStatsResolver implementation.
func (r *Resolver) ContractStats() generated.ContractStatsResolver { return &contractStatsResolver{r} }

// Event returns generated.EventResolver implementation.
func (r *Resolver) Event() generated.EventResolver { return &eventResolver{r} }

// EventArg returns generated.EventArgResolver implementation.
func (r *Resolver) EventArg() generated.EventArgResolver { return &eventArgResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// AddContractInput returns generated.AddContractInputResolver implementation.
func (r *Resolver) AddContractInput() generated.AddContractInputResolver {
	return &addContractInputResolver{r}
}

// EventFilter returns generated.EventFilterResolver implementation.
func (r *Resolver) EventFilter() generated.EventFilterResolver { return &eventFilterResolver{r} }

type contractResolver struct{ *Resolver }
type contractStatsResolver struct{ *Resolver }
type eventResolver struct{ *Resolver }
type eventArgResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type addContractInputResolver struct{ *Resolver }
type eventFilterResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *contractStatsResolver) UniqueAddresses(ctx context.Context, obj *models.ContractStats) (*int, error) {
	if obj.UniqueAddresses == nil {
		return nil, nil
	}
	value := *obj.UniqueAddresses
	return &value, nil
}
func (r *eventResolver) RawLog(ctx context.Context, obj *models.Event) (*string, error) {
	return obj.RawLog, nil
}
func applyEventFilter(req *protoapi.EventQuery, filter *models.EventFilter) {
	if filter == nil {
		return
	}
	if filter.ContractAddress != nil {
		req.ContractAddress = string(*filter.ContractAddress)
	}
	if filter.EventName != nil {
		req.EventName = *filter.EventName
	}
	if filter.FromBlock != nil {
		req.FromBlock = *filter.FromBlock
	}
	if filter.ToBlock != nil {
		req.ToBlock = *filter.ToBlock
	}
	if filter.TransactionHash != nil {
		req.TransactionHash = string(*filter.TransactionHash)
	}
	if len(filter.Addresses) > 0 {
		req.Addresses = make([]string, len(filter.Addresses))
		for i, addr := range filter.Addresses {
			req.Addresses[i] = string(addr)
		}
	} else if filter.Address != nil {
		req.Addresses = []string{string(*filter.Address)}
	}
}
func applyPagination(req *protoapi.EventQuery, pagination *model.PaginationInput) {
	if pagination == nil {
		return
	}
	if pagination.First != nil {
		req.First = int32(*pagination.First)
	}
	if pagination.After != nil {
		req.After = *pagination.After
	}
	if pagination.Before != nil {
		req.Before = *pagination.Before
	}
	if pagination.Last != nil {
		req.Last = int32(*pagination.Last)
	}
}
func loadContract(ctx context.Context, db *sql.DB, address string) (*models.Contract, error) {
	key := strings.ToLower(strings.TrimSpace(address))
	if loaders := GetLoaders(ctx); loaders != nil && loaders.ContractByAddress != nil {
		return loaders.ContractByAddress.Load(ctx, key)()
	}
	return getContractByAddress(ctx, db, key)
}

func loadContractStats(ctx context.Context, db *sql.DB, address string) (*models.ContractStats, error) {
	key := strings.ToLower(strings.TrimSpace(address))
	if loaders := GetLoaders(ctx); loaders != nil && loaders.StatsByAddress != nil {
		return loaders.StatsByAddress.Load(ctx, key)()
	}
	return queryContractStats(ctx, db, key)
}
func getContractByAddress(ctx context.Context, db *sql.DB, address string) (*models.Contract, error) {
	query := `
SELECT id, address, abi, name, start_block, current_block, confirm_blocks, created_at, updated_at
FROM contracts
WHERE LOWER(address) = $1
`
	row := db.QueryRowContext(ctx, query, address)
	var contract models.Contract
	if err := row.Scan(
		&contract.ID,
		&contract.Address,
		&contract.ABI,
		&contract.Name,
		&contract.StartBlock,
		&contract.CurrentBlock,
		&contract.ConfirmBlocks,
		&contract.CreatedAt,
		&contract.UpdatedAt,
	); err != nil {
		return nil, err
	}
	return &contract, nil
}
func queryContractStats(ctx context.Context, db *sql.DB, address string) (*models.ContractStats, error) {
	query := `
WITH uniq_addresses AS (
    SELECT e.contract_address,
           COUNT(DISTINCT LOWER(value)) FILTER (WHERE value LIKE '0x%') AS unique_addresses
    FROM events e,
         LATERAL jsonb_each_text(e.args)
    WHERE LOWER(e.contract_address) = $1
    GROUP BY e.contract_address
)
SELECT 
    c.address,
    COUNT(e.id) AS total_events,
    COALESCE(MAX(e.block_number), c.current_block) AS latest_block,
    c.current_block,
    GREATEST(c.current_block - COALESCE(MAX(e.block_number), c.start_block), 0) AS indexer_delay,
    COALESCE(MAX(e.created_at), c.updated_at) AS last_updated,
    COALESCE(u.unique_addresses, 0) AS unique_addresses
FROM contracts c
LEFT JOIN events e ON c.address = e.contract_address
LEFT JOIN uniq_addresses u ON u.contract_address = c.address
WHERE LOWER(c.address) = $1
GROUP BY c.address, c.current_block, c.start_block, c.updated_at, u.unique_addresses
`
	row := db.QueryRowContext(ctx, query, address)
	var stats models.ContractStats
	var lastUpdated time.Time
	var uniqueAddresses int64
	if err := row.Scan(
		&stats.ContractAddress,
		&stats.TotalEvents,
		&stats.LatestBlock,
		&stats.CurrentBlock,
		&stats.IndexerDelay,
		&lastUpdated,
		&uniqueAddresses,
	); err != nil {
		return nil, err
	}
	stats.LastUpdated = lastUpdated
	if uniqueAddresses > 0 {
		value := int(uniqueAddresses)
		stats.UniqueAddresses = &value
	}
	return &stats, nil
}
